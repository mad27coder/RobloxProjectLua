local Players = game:GetService("Players")
local player = Players.LocalPlayer
local UIS = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")

local screenGui = Instance.new("ScreenGui", game.CoreGui)
screenGui.Name = "Joystick"

local sizeOuter, sizeInner = 110, 50
local radius = sizeOuter / 2
local center, dragging, activeTouch

local outer = Instance.new("ImageLabel", screenGui)
outer.Size = UDim2.fromOffset(sizeOuter, sizeOuter)
outer.Position = UDim2.new(0.1, 0, 0.75, 0)
outer.AnchorPoint = Vector2.new(0.5, 0.5)
outer.BackgroundColor3 = Color3.fromRGB(80, 80, 80)
outer.BackgroundTransparency = 0.3
outer.BorderSizePixel = 0
outer.ZIndex = 1
outer.Active = true
outer.Image = "rbxasset://textures/ui/TouchControlsSheet.png"
outer.ImageRectSize = Vector2.new(220, 220)
Instance.new("UICorner", outer).CornerRadius = UDim.new(1,0)

local inner = Instance.new("ImageLabel", outer)
inner.Size = UDim2.fromOffset(sizeInner, sizeInner)
inner.Position = UDim2.new(0.5, -sizeInner/2, 0.5, -sizeInner/2)
inner.BackgroundColor3 = Color3.fromRGB(150,150,150)
inner.BorderSizePixel = 0
inner.ZIndex = 2
inner.Active = true
inner.Image = "rbxasset://textures/ui/TouchControlsSheet.png"
inner.ImageRectOffset = Vector2.new(220, 0)
inner.ImageRectSize = Vector2.new(111, 111)
Instance.new("UICorner", inner).CornerRadius = UDim.new(1,0)

_G.JoystickData = {
    DraggingLevel = 0,
    Direction = Vector3.new(0,0,0)
}

local function toV2(pos)
    return Vector2.new(pos.X, pos.Y)
end

local function updateCenter()
    center = Vector2.new(
        outer.AbsolutePosition.X + radius,
        outer.AbsolutePosition.Y + radius
    )
end

local function moveInner(posV2)
    local dir = posV2 - center
    local dist = math.min(dir.Magnitude, radius)
    local offset = dir.Magnitude > 0 and dir.Unit * dist or Vector2.new(0,0)
    inner.Position = UDim2.new(0.5, offset.X - sizeInner/2, 0.5, offset.Y - sizeInner/2)

    -- Digital-style direction
    local threshold = 0.3
    local dirX = math.abs(offset.X / radius) > threshold and math.sign(offset.X) or 0
    local dirZ = math.abs(offset.Y / radius) > threshold and math.sign(offset.Y) or 0
    local dir3 = Vector3.new(dirX, 0, dirZ)
    local dragLevel = (dirX ~= 0 or dirZ ~= 0) and 100 or 0

    _G.JoystickData.DraggingLevel = dragLevel
    _G.JoystickData.Direction = dir3
end

local function animatePress()
    TweenService:Create(outer, TweenInfo.new(0.15, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
        Size = UDim2.fromOffset(sizeOuter * 1.1, sizeOuter * 1.1),
        BackgroundColor3 = Color3.fromRGB(120,120,120)
    }):Play()
    TweenService:Create(inner, TweenInfo.new(0.15, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
        Size = UDim2.fromOffset(sizeInner * 1.2, sizeInner * 1.2),
        BackgroundColor3 = Color3.fromRGB(200,200,200)
    }):Play()
end

local function animateRelease()
    TweenService:Create(outer, TweenInfo.new(0.2, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
        Size = UDim2.fromOffset(sizeOuter, sizeOuter),
        BackgroundColor3 = Color3.fromRGB(80,80,80)
    }):Play()
    TweenService:Create(inner, TweenInfo.new(0.2, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
        Size = UDim2.fromOffset(sizeInner, sizeInner),
        BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    }):Play()
end

for _, obj in ipairs({outer, inner}) do
    obj.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.Touch and not dragging then
            updateCenter()
            dragging = true
            activeTouch = input
            moveInner(toV2(input.Position))
            animatePress()
        end
    end)
end

UIS.TouchMoved:Connect(function(input)
    if dragging and activeTouch and input == activeTouch then
        moveInner(toV2(input.Position))
    end
end)

UIS.TouchEnded:Connect(function(input)
    if dragging and activeTouch and input == activeTouch then
        dragging = false
        activeTouch = nil
        inner.Position = UDim2.new(0.5, -sizeInner/2, 0.5, -sizeInner/2)
        _G.JoystickData.DraggingLevel = 0
        _G.JoystickData.Direction = Vector3.new(0,0,0)
        animateRelease()
    end
end)

-- Joystick Setup
local sizeOuter, sizeInner = 110, 50
local radius = sizeOuter / 2
local center, dragging, activeTouch

local outer = Instance.new("ImageLabel", ScreenGui)
outer.Size = UDim2.fromOffset(sizeOuter, sizeOuter)
outer.Position = UDim2.new(0.1, 0, 0.75, 0)
outer.AnchorPoint = Vector2.new(0.5, 0.5)
outer.BackgroundColor3 = Color3.fromRGB(80, 80, 80)
outer.BackgroundTransparency = 0.3
outer.BorderSizePixel = 0
outer.ZIndex = 5
outer.Active = true
outer.Image = "rbxasset://textures/ui/TouchControlsSheet.png"
outer.ImageRectSize = Vector2.new(220, 220)
Instance.new("UICorner", outer).CornerRadius = UDim.new(1,0)

local inner = Instance.new("ImageLabel", outer)
inner.Size = UDim2.fromOffset(sizeInner, sizeInner)
inner.Position = UDim2.new(0.5, -sizeInner/2, 0.5, -sizeInner/2)
inner.BackgroundColor3 = Color3.fromRGB(150,150,150)
inner.BorderSizePixel = 0
inner.ZIndex = 6
inner.Active = true
inner.Image = "rbxasset://textures/ui/TouchControlsSheet.png"
inner.ImageRectOffset = Vector2.new(220, 0)
inner.ImageRectSize = Vector2.new(111, 111)
Instance.new("UICorner", inner).CornerRadius = UDim.new(1,0)

_G.JoystickData = {
    DraggingLevel = 0,
    Direction = Vector3.new(0,0,0)
}

local function toV2(pos)
    return Vector2.new(pos.X, pos.Y)
end

local function updateCenter()
    center = Vector2.new(
        outer.AbsolutePosition.X + radius,
        outer.AbsolutePosition.Y + radius
    )
end

local function moveInner(posV2)
    local dir = posV2 - center
    local dist = math.min(dir.Magnitude, radius)
    local offset = dir.Magnitude > 0 and dir.Unit * dist or Vector2.new(0,0)
    inner.Position = UDim2.new(0.5, offset.X - sizeInner/2, 0.5, offset.Y - sizeInner/2)

    -- Digital-style direction
    local threshold = 0.3
    local dirX = math.abs(offset.X / radius) > threshold and math.sign(offset.X) or 0
    local dirZ = math.abs(offset.Y / radius) > threshold and math.sign(offset.Y) or 0
    local dir3 = Vector3.new(dirX, 0, dirZ)
    local dragLevel = (dirX ~= 0 or dirZ ~= 0) and 100 or 0

    _G.JoystickData.DraggingLevel = dragLevel
    _G.JoystickData.Direction = dir3
end

local function animatePress()
    TweenService:Create(outer, TweenInfo.new(0.15, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
        Size = UDim2.fromOffset(sizeOuter * 1.1, sizeOuter * 1.1),
        BackgroundColor3 = Color3.fromRGB(120,120,120)
    }):Play()
    TweenService:Create(inner, TweenInfo.new(0.15, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
        Size = UDim2.fromOffset(sizeInner * 1.2, sizeInner * 1.2),
        BackgroundColor3 = Color3.fromRGB(200,200,200)
    }):Play()
end

local function animateRelease()
    TweenService:Create(outer, TweenInfo.new(0.2, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
        Size = UDim2.fromOffset(sizeOuter, sizeOuter),
        BackgroundColor3 = Color3.fromRGB(80,80,80)
    }):Play()
    TweenService:Create(inner, TweenInfo.new(0.2, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
        Size = UDim2.fromOffset(sizeInner, sizeInner),
        BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    }):Play()
end

for _, obj in ipairs({outer, inner}) do
    obj.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.Touch and not dragging then
            updateCenter()
            dragging = true
            activeTouch = input
            moveInner(toV2(input.Position))
            animatePress()
        end
    end)
end

UIS.TouchMoved:Connect(function(input)
    if dragging and activeTouch and input == activeTouch then
        moveInner(toV2(input.Position))
    end
end)

UIS.TouchEnded:Connect(function(input)
    if dragging and activeTouch and input == activeTouch then
        dragging = false
        activeTouch = nil
        inner.Position = UDim2.new(0.5, -sizeInner/2, 0.5, -sizeInner/2)
        _G.JoystickData.DraggingLevel = 0
        _G.JoystickData.Direction = Vector3.new(0,0,0)
        animateRelease()
    end
end)

-- FreeCam Setup
local camera = workspace.CurrentCamera
local movePart = Instance.new("Part", workspace)
movePart.Size = Vector3.new(0, 0, 0)
movePart.Anchored = true
movePart.Transparency = 1
movePart.CanCollide = false
movePart.Name = "CameraPart"
movePart.CFrame = camera.CFrame

local currentPos = movePart.Position
local verticalDir = 0

-- Toggle FreeCam Button
local freeCamToggle = Instance.new("TextButton", ScreenGui)
freeCamToggle.Size = UDim2.new(0, 120, 0, 50)
freeCamToggle.Position = UDim2.new(0, 30, 0, 30)
freeCamToggle.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
freeCamToggle.TextColor3 = Color3.new(1, 1, 1)
freeCamToggle.Text = "FreeCam ON"
freeCamToggle.Active = true
freeCamToggle.Draggable = true

-- Tombol Naik & Turun
local upBtn = Instance.new("TextButton", ScreenGui)
upBtn.Size = UDim2.new(0, 60, 0, 60)
upBtn.Position = UDim2.new(1, -80, 0.5, -70)
upBtn.BackgroundColor3 = Color3.fromRGB(70, 130, 180)
upBtn.TextColor3 = Color3.new(1, 1, 1)
upBtn.Text = "↑"
upBtn.TextScaled = true
upBtn.Font = Enum.Font.SourceSansBold
upBtn.Visible = true

local downBtn = Instance.new("TextButton", ScreenGui)
downBtn.Size = UDim2.new(0, 60, 0, 60)
downBtn.Position = UDim2.new(1, -80, 0.5, 10)
downBtn.BackgroundColor3 = Color3.fromRGB(70, 130, 180)
downBtn.TextColor3 = Color3.new(1, 1, 1)
downBtn.Text = "↓"
downBtn.TextScaled = true
downBtn.Font = Enum.Font.SourceSansBold
downBtn.Visible = true

-- Event Tombol Naik/Turun
upBtn.MouseButton1Down:Connect(function() verticalDir = 1 end)
upBtn.MouseButton1Up:Connect(function() verticalDir = 0 end)
downBtn.MouseButton1Down:Connect(function() verticalDir = -1 end)
downBtn.MouseButton1Up:Connect(function() verticalDir = 0 end)

-- Toggle Logic
local freeCamEnabled = true

local function applyFreeCam(state)
    freeCamEnabled = state
    freeCamToggle.Text = state and "FreeCam ON" or "FreeCam OFF"
    upBtn.Visible = state
    downBtn.Visible = state

    if state then
        camera.CameraSubject = movePart
        camera.CameraType = Enum.CameraType.Custom
    else
        camera.CameraSubject = Players.LocalPlayer.Character and Players.LocalPlayer.Character:FindFirstChild("Humanoid") or nil
    end
end

freeCamToggle.MouseButton1Click:Connect(function()
    applyFreeCam(not freeCamEnabled)
end)

applyFreeCam(true)

-- Movement Logic
game:GetService("RunService").RenderStepped:Connect(function(dt)
    if not freeCamEnabled then return end

    local dir = _G.JoystickData.Direction
    local level = _G.JoystickData.DraggingLevel

    if level > 0 then
        local moveSpeed = 0.5
        local camCF = camera.CFrame
        local forward = camCF.LookVector
        local right = camCF.RightVector
        local moveDir = (forward * -dir.Z) + (right * dir.X)
        moveDir = moveDir.Unit
        currentPos = currentPos + moveDir * moveSpeed * dt * 60
    end

    if verticalDir ~= 0 then
        currentPos = currentPos + Vector3.new(0, verticalDir * 0.5, 0)
    end

    local camLook = camera.CFrame.LookVector
    local yaw = math.atan2(camLook.X, camLook.Z)
    movePart.CFrame = CFrame.new(currentPos) * CFrame.Angles(0, yaw, 0)
end)